ASF2MC8 Branch Displacement
---------------------------

asf2mc8 disassembles branches incorrectly:

    .org 0xe000
    bne 0xdffe       ;uses low byte (0xfe) for displacement instead of
                     ;  calculating displacement from PC to 0xdfee

For branch displacement to be calculated, the target has to be an actual
label.  An absolute value or an equate won't work.

Address Marking
---------------

An address might the target of both a JMP and a CALL.  If it is, it should
be marked as a subroutine ("sub_*") not label ("lab_*").

Branch to Middle of Instruction
-------------------------------

Disassembly of data generated by /dev/urandom:

    lab_f0be:
        bne lab_f0bf            ;f0be  fc ff
        cmp a, r2               ;f0c0  1a
        clri                    ;f0c1  80

Assembly fails because lab_f0bf does not exist.  The address 0xf0be is in the
middle of the "bne" instruction.

Call Outside of ROM
-------------------

Disassembly of data generated by /dev/urandom:

    mov r2, #0x5e           ;e00a  8a 5e
    mov r2, a               ;e00c  4a
    call sub_4f69           ;e00d  31 4f 69
    inc r2                  ;e010  ca

Assembly fails because sub_4f69 does not exist.  It's outside of the ROM area
of 0xe000-0xfff.

Jump Outside of ROM
-------------------

Disassembly of data generated by /dev/urandom:

    cmp r7, #0xbf           ;df55  9f bf
    divu a                  ;df57  11
    jmp lab_6fd5            ;df58  21 6f d5
    .byte 0x54              ;df5b  54          DATA 'T'

Assembly fails because lab_6fd5 does not exist.  It's outside of the ROM area
of 0xe000-0xffff.

Code Flows into Vector Area
---------------------------

If a code path doesn't stop before the hardware vectors at top of memory, the
vectors will be classified as code.  They should remain vectors.
