ASF2MC8 Branch Displacement
---------------------------

asf2mc8 assembles branches with absolute addresses incorrectly:

    .org 0xe000
    bne 0xdffe       ;uses low byte (0xfe) for displacement instead of
                     ;  calculating displacement from PC to 0xdffe

For branch displacement to be calculated, the target has to be an actual
label.  An absolute literal or an equate won't work.

asf2mc8 does assemble branches correctly relative to the program counter:

    .org 0xe000
    bne .            ;correctly computes branch to 0xe000:
                     ;E000 FC FE    [ 3]    26  bne .

    .org 0xe000
    bne .-2          ;correctly computes branch to 0xe000 - 2:
                     ;E000 FC FC    [ 3]    29 	bne .-2


Address Marking
---------------

An address might the target of both a JMP and a CALL.  If it is, it should
be marked as a subroutine ("sub_*") not label ("lab_*").

Branch to Middle of Instruction
-------------------------------

Disassembly of data generated by /dev/urandom:

    lab_f0be:
        bne lab_f0bf            ;f0be  fc ff
        cmp a, r2               ;f0c0  1a
        clri                    ;f0c1  80

Assembly fails because lab_f0bf does not exist.  The address 0xf0be is in the
middle of the "bne" instruction.

Call Outside of ROM
-------------------

Disassembly of data generated by /dev/urandom:

    mov r2, #0x5e           ;e00a  8a 5e
    mov r2, a               ;e00c  4a
    call sub_4f69           ;e00d  31 4f 69
    inc r2                  ;e010  ca

Assembly fails because sub_4f69 does not exist.  It's outside of the ROM area
of 0xe000-0xfff.

Jump Outside of ROM
-------------------

Disassembly of data generated by /dev/urandom:

    cmp r7, #0xbf           ;df55  9f bf
    divu a                  ;df57  11
    jmp lab_6fd5            ;df58  21 6f d5
    .byte 0x54              ;df5b  54          DATA 'T'

Assembly fails because lab_6fd5 does not exist.  It's outside of the ROM area
of 0xe000-0xffff.

Code Flows into Vector Area
---------------------------

If a code path doesn't stop before the hardware vectors at top of memory, the
vectors will be classified as code.  They should remain vectors.
